<#
Script PowerShell
Utilisé par Nicolas GRUBER - Tebicom | Généré avec l'aide de ChatGPT (OpenAI)
Date intitiale : 27.09.2025
Résumé : Pré-Diagnostic automatique complet Windows Server/Endpoint (user+admin compatible)

Version 0.91 - 28.10.2025
#>

cls

# To DO - récup taille profil utilisateur de merde 
# TO DO - drivers - afficher date du pilote
# Drvier printer - détecter les drivers postérieur à 2022

# ====================================================================
# QD - INITIALISATION : TRANSCRIPT GLOBAL
# ====================================================================
try { #madebymoi with GhostEngineer
    if ($MyInvocation.MyCommand.Path) {
        $ScriptPath  = Split-Path -Parent $MyInvocation.MyCommand.Path
        $rapportPath = Join-Path $ScriptPath ("Diagnostic-Windows-{0}.txt" -f (Get-Date -Format 'yyyyMMdd-HHmm'))
        Start-Transcript -Path $rapportPath -Force | Out-Null
    }
    else {
        Write-Host "⚠️ Script lancé depuis la console/ISE → Pas de chemin pour export." -ForegroundColor Yellow
        $rapportPath = $null
    }
}
catch {
    Write-Host "⚠️ Impossible de démarrer le transcript (erreur d’écriture)." -ForegroundColor Yellow
    $rapportPath = $null
}


# ====================================================================
# QD - INITIALISATION : Mesure CPU en arrière-plan
# ====================================================================
$SampleInterval = 1   # secondes entre mesures
$SampleCount    = 10  # durée totale = 10s

$cpuJob = Start-Job -ScriptBlock {
    param($SampleInterval,$SampleCount)
    $samples = Get-Counter '\Processor(_Total)\% Processor Time' -SampleInterval $SampleInterval -MaxSamples $SampleCount
    $avg = ($samples.CounterSamples.CookedValue | Measure-Object -Average).Average
    [math]::Round($avg,1)
} -ArgumentList $SampleInterval,$SampleCount


# ====================================================================
# QD - BLOC 1 : INFOS SYSTEME
# ====================================================================
Write-Host "=== Diagnostic rapide de Windows Server / Endpoint ===" -ForegroundColor Cyan


$FQDN = [System.Net.Dns]::GetHostByName(($env:computerName)).HostName
$OS   = Get-CimInstance Win32_OperatingSystem
$CS   = Get-CimInstance Win32_ComputerSystem
$BIOS = Get-CimInstance Win32_BIOS
$LastReboot = $OS.LastBootUpTime
$LastReboot  = $LastReboot.ToString("dd MMMM yyyy HH:mm:ss", [System.Globalization.CultureInfo]::GetCultureInfo("fr-FR"))
# Format FR clair pour la mise en service
$InstallDate    = $OS.InstallDate.ToString("dd MMMM yyyy HH:mm:ss", [System.Globalization.CultureInfo]::GetCultureInfo("fr-FR"))


function Get-WindowsRelease {
    param([string]$BuildNumber)
    switch ($BuildNumber) {
        {$_ -gt 26100} { return "Version trop récente pour le script (build $BuildNumber)" }
        {$_ -ge 26100} { return "24H2" }
        {$_ -ge 22631} { return "23H2" }
        {$_ -ge 22621} { return "22H2" }
        {$_ -ge 22000} { return "21H2" }
        {$_ -ge 19045} { return "22H2 (Win10)" }
        {$_ -ge 19044} { return "21H2 (Win10)" }
        default { return "Inconnu ($BuildNumber)" }
    }
}
$Release = Get-WindowsRelease -BuildNumber $OS.BuildNumber

# Recherche de la dernière mise à jour installée avec parsing robuste
$LastWU = Get-WmiObject -Class "Win32_QuickFixEngineering" |
          Where-Object { $_.InstalledOn -ne $null -and $_.InstalledOn -ne "" } |
          Sort-Object {
              if ($_.InstalledOn -is [datetime]) {
                  $_.InstalledOn
              } else {
                  [datetime]::Parse($_.InstalledOn)
              }
          } -Descending |
          Select-Object -First 1

if ($LastWU) {
    $DateMAJ = if ($LastWU.InstalledOn -is [datetime]) {
        $LastWU.InstalledOn
    } else {
        [datetime]::Parse($LastWU.InstalledOn)
    }

    # Format clair FR (mois en toutes lettres)
    $LastUpdateFmt = $DateMAJ.ToString("dd MMMM yyyy HH:mm:ss", [System.Globalization.CultureInfo]::GetCultureInfo("fr-FR"))
    $LastUpdateStr = "$LastUpdateFmt ($($LastWU.HotFixID))"
} else {
    $LastUpdateStr = "Non trouvé"
}

# Détection de langue OS
$osLang = (Get-Culture).TwoLetterISOLanguageName
if ($osLang -in @('fr','en','de')) {
    $LangColor = "Gray"
    $LangMsg   = "Langue détectée : $osLang"
} else {
    $LangColor = "Yellow"
    $LangMsg   = "Langue détectée : $osLang ⚠ NON supportée officiellement (FR/EN/DE uniquement)"
}

# Affichage aligné
Write-Host ("{0,-22}: {1}" -f "Nom FQDN", $FQDN)  -ForegroundColor White
Write-Host ("{0,-22}: {1} {2}" -f "OS Version", $OS.Caption, $Release)
Write-Host ("{0,-22}: {1}" -f "Dernière MAJ", $LastUpdateStr)
Write-Host ("{0,-22}: {1}" -f "Dernier reboot", $LastReboot)
Write-Host ("{0,-22}: {1}" -f "Mise en service", $InstallDate)
Write-Host ("{0,-22}: {1}" -f "Modèle", "$($CS.Manufacturer) $($CS.Model)")
Write-Host ("{0,-22}: {1}" -f "N° de série", $BIOS.SerialNumber)
Write-Host ("{0,-22}: {1}" -f "Langue système", $LangMsg) -ForegroundColor $LangColor
# Vérifie si le Fast Startup est activé
$fastBootValue = Get-ItemPropertyValue -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Power" -Name HiberbootEnabled -ErrorAction SilentlyContinue
$FastBootStatus = if ($fastBootValue -eq 1) { "Activé" } elseif ($fastBootValue -eq 0) { "Désactivé" } else { "Non supporté" }
Write-Host ("{0,-22}: {1}" -f "FastBoot", $FastBootStatus) -ForegroundColor DarkGray


# ====================================================================
# QD - BLOC 2 : INTEGRATION ANNUAIRE & OAUTH LOCAL
# ====================================================================
Write-Host "`n=== Intégration annuaire / Azure AD / OAuth ===" -ForegroundColor Cyan

try {
    # ----------------------------------------------------------------
    # Extraction d'informations système
    # ----------------------------------------------------------------
    $cs = Get-CimInstance Win32_ComputerSystem
    $dsreg = dsregcmd /status 2>$null

    $aadJoin       = ($dsreg -match "AzureAdJoined\s*:\s*YES")
    $workplaceJoin = ($dsreg -match "WorkplaceJoined\s*:\s*YES")
    $prtActive     = ($dsreg -match "AzureAdPrt\s*:\s*YES")
    $domainJoin    = $cs.PartOfDomain

    try {
        $executingAccount = (whoami /upn 2>$null)
        if (-not $executingAccount) { $executingAccount = (whoami) }
    } catch { $executingAccount = (whoami) }

    # ----------------------------------------------------------------
    # Détection du type d’intégration
    # ----------------------------------------------------------------
    $integrationType = "Workgroup / Non joint"
    if ($aadJoin -and $domainJoin) { $integrationType = "HYBRID JOIN (AD + Azure AD)" }
    elseif ($aadJoin)              { $integrationType = "Azure AD Join" }
    elseif ($domainJoin)           { $integrationType = "Domain Join" }

    Write-Host ""
    Write-Host "Type d'intégration : $integrationType" -ForegroundColor White
    Write-Host ""

    if ($executingAccount) {
        Write-Host "Identité utilisateur : $executingAccount" -ForegroundColor Cyan
    }

    # ----------------------------------------------------------------
    # Gestion de l'affichage PRT / OAuth selon le type d’intégration
    # ----------------------------------------------------------------
    if ($aadJoin -or $workplaceJoin) {
        if ($prtActive) {
            Write-Host "PRT (SSO) : Actif" -ForegroundColor Green
        }
        else {
            Write-Host "PRT (SSO) : Inactif" -ForegroundColor Red
        }

        # Informations détaillées PRT (dates)
        $prtInfo = $dsreg | Select-String -Pattern "PrtUpdateTime|PrtExpiryTime|AzureAdPrtUpdateTime|AzureAdPrtExpiryTime"
        if ($prtInfo) {
            Write-Host "`nDétails PRT :" -ForegroundColor Cyan
            foreach ($line in $prtInfo) {
                $name, $value = $line.ToString() -split ":", 2
                $name  = $name.Trim()
                $value = $value.Trim()
                Write-Host ("{0,-25}: {1}" -f $name, $value) -ForegroundColor White
            }
        } else {
            Write-Host "`nAucune information de date PRT trouvée dans dsregcmd /status" -ForegroundColor DarkGray
        }
    }
    else {
        Write-Host "Aucun compte AzureAD ou MSA détecté – pas de PRT applicable." -ForegroundColor DarkGray
    }

    # ----------------------------------------------------------------
    # Comptes AzureAD listés via dsregcmd
    # ----------------------------------------------------------------
    $rawList = dsregcmd /listaccounts 2>$null
    $azureAccounts = @()
    $defaultAccountId = $null

    if ($rawList) {
        $lines = $rawList -split "`r?`n"
        foreach ($line in $lines) {
            $t = $line.Trim()
            if ($t -match '^Account:\s*(?<id>[^,]+),\s*user:\s*(?<user>[^,]+),\s*authority:\s*(?<auth>.+?)[\.\r\n]*$') {
                $azureAccounts += [PSCustomObject]@{
                    AccountId = $matches['id'].Trim()
                    User      = $matches['user'].Trim()
                    Authority = $matches['auth'].Trim().TrimEnd('.')
                    IsDefault = $false
                }
            }
            elseif ($t -match '^Default account:\s*(?<id>[^,]+),\s*user:\s*(?<user>.+)$') {
                $defaultAccountId = $matches['id'].Trim()
            }
        }
        if ($defaultAccountId) {
            foreach ($a in $azureAccounts) {
                if ($a.AccountId -eq $defaultAccountId) { $a.IsDefault = $true; break }
            }
        }
    }

    if ($azureAccounts.Count -gt 0) {
        Write-Host "`nComptes AzureAD :" -ForegroundColor Cyan
        $header = "{0,-8} {1,-28} {2,-36} {3,-36}" -f "Type","User","UID","TID"
        Write-Host $header -ForegroundColor White
        Write-Host ("-" * $header.Length) -ForegroundColor DarkGray

        foreach ($a in $azureAccounts) {
            $userGuid = "-"
            $tenantGuid = "-"
            if ($a.AccountId -match '^u:(?<uid>[^\.]+)\.(?<tid>.+)$') {
                $userGuid = $matches['uid']
                $tenantGuid = $matches['tid']
            }
            $tokenType = if ($a.IsDefault -and $prtActive) { "PRT" } else { "RT" }
            $line = "{0,-8} {1,-28} {2,-36} {3,-36}" -f $tokenType,$a.User,$userGuid,$tenantGuid
            Write-Host $line -ForegroundColor White
        }
    } else {
        Write-Host "Aucun compte AzureAD détecté" -ForegroundColor DarkGray
    }

    # ----------------------------------------------------------------
    # Comptes Microsoft (MSA) via cmdkey / StoredIdentities
    # ----------------------------------------------------------------
    $rawCmdKey = cmdkey /list 2>$null
    $msaAccounts = @()
    if ($rawCmdKey) {
        $cklines = $rawCmdKey -split "`r?`n"
        for ($i = 0; $i -lt $cklines.Count; $i++) {
            $l = $cklines[$i].Trim()
            if ($l -match 'Cible\s*:\s*MicrosoftAccount:.*user=(?<user>[\w\.\-\+@]+)') {
                $msaAccounts += $matches['user'].Trim()
            }
            if ($l -match 'Cible\s*:\s*LegacyGeneric:target=MicrosoftAccount:user=(?<user>[\w\.\-\+@]+)') {
                $msaAccounts += $matches['user'].Trim()
            }
        }
        $msaAccounts = $msaAccounts | Select-Object -Unique
    }

    $storedIdentities = @()
    try {
        $keyPath = "HKCU:\Software\Microsoft\IdentityCRL\StoredIdentities"
        if (Test-Path $keyPath) {
            Get-ChildItem $keyPath | ForEach-Object {
                $props = Get-ItemProperty -Path $_.PSPath
                if ($props.PSObject.Properties.Name -contains 'DisplayableId') {
                    $storedIdentities += $props.DisplayableId
                } elseif ($props.PSObject.Properties.Name -contains 'UserName') {
                    $storedIdentities += $props.UserName
                }
            }
            $storedIdentities = $storedIdentities | Select-Object -Unique
        }
    } catch {}

    if ($msaAccounts.Count -gt 0 -or $storedIdentities.Count -gt 0) {
        Write-Host "`nComptes Microsoft (MSA) :" -ForegroundColor Cyan
        foreach ($m in $msaAccounts) { Write-Host ("  {0}" -f $m) -ForegroundColor White }
        foreach ($s in $storedIdentities) {
            if (-not ($msaAccounts -contains $s)) { Write-Host ("  {0}" -f $s) -ForegroundColor White }
        }
    } else {
        Write-Host "Aucun compte MSA détecté" -ForegroundColor DarkGray
    }

} catch {
    Write-Host "⚠️ Erreur lors de la détection de l’intégration annuaire / OAuth : $($_.Exception.Message)" -ForegroundColor Yellow
}



# ====================================================================
# QD - BLOC 3 : RESEAU & CONNECTIVITE
# ====================================================================
Write-Host "`n=== Réseau & Connectivité ===" -ForegroundColor Cyan

# Domaine utilisé pour tester la résolution DNS
$DnsTestDomain = "www.microsoft.com"
$DnsFallback   = "www.google.ch"

Write-Host "(Résolution DNS testée sur $DnsTestDomain, fallback $DnsFallback)" -ForegroundColor DarkGray

# Test rapide si le domaine principal répond, sinon fallback
try {
    $testRes = Resolve-DnsName $DnsTestDomain -ErrorAction Stop
}
catch {
    Write-Host "⚠️ $DnsTestDomain ne répond pas, utilisation du fallback $DnsFallback" -ForegroundColor Yellow
    $DnsTestDomain = $DnsFallback
}

try {
    $nics = Get-NetAdapter | Where-Object { $_.Status -eq "Up" } | Sort-Object ifIndex
    if ($nics) {
        foreach ($nic in $nics) {
            $ips       = Get-NetIPAddress -InterfaceIndex $nic.ifIndex -AddressFamily IPv4 -ErrorAction SilentlyContinue
            $dns       = (Get-DnsClientServerAddress -InterfaceIndex $nic.ifIndex -AddressFamily IPv4 -ErrorAction SilentlyContinue).ServerAddresses
            $profile   = Get-NetConnectionProfile -InterfaceIndex $nic.ifIndex -ErrorAction SilentlyContinue
            $dnsClient = Get-DnsClient -InterfaceIndex $nic.ifIndex -ErrorAction SilentlyContinue

            # Récupération de la passerelle via route 0.0.0.0/0
            $gw = (Get-NetRoute -InterfaceIndex $nic.ifIndex -DestinationPrefix "0.0.0.0/0" -ErrorAction SilentlyContinue).NextHop

            foreach ($ip in $ips) {
                Write-Host ("Interface {0} ({1})" -f $nic.Name, $nic.InterfaceDescription) -ForegroundColor Cyan
                Write-Host ("Adresse IP    : {0}/{1}" -f $ip.IPAddress, $ip.PrefixLength)
                Write-Host ("Adresse MAC   : {0}" -f $nic.MacAddress)

                if ($profile) {
                    Write-Host ("Profil réseau : {0}" -f $profile.NetworkCategory)
                }

                if ($dnsClient -and $dnsClient.ConnectionSpecificSuffix) {
                    Write-Host ("Suffixe DNS   : {0}" -f $dnsClient.ConnectionSpecificSuffix)
                }

                # DHCP ou statique
                if ($ip.AddressState -eq "Preferred") {
                    if ($ip.PrefixOrigin -eq "Dhcp") {
                        Write-Host "Mode IP       : DHCP"
                    } else {
                        Write-Host "Mode IP       : Statique"
                    }
                }

                # --- Passerelles
                if ($gw) {
                    foreach ($g in $gw) {
                        $pingGW = Test-Connection -ComputerName $g -Count 1 -Quiet -ErrorAction SilentlyContinue
                        if ($pingGW) { Write-Host ("Passerelle    : {0} (ping OK)" -f $g) -ForegroundColor Green }
                        else         { Write-Host ("Passerelle    : {0} (ping FAIL)" -f $g) -ForegroundColor Red }
                    }
                } else {
                    Write-Host "Passerelle    : (aucune ou inaccessible)" -ForegroundColor Yellow
                }

                # --- DNS
                if ($dns) {
                    Write-Host "Serveur DNS   :"
                    foreach ($server in $dns) {
                        try {
                            $pingResult = Test-Connection -ComputerName $server -Count 1 -ErrorAction SilentlyContinue
                            if ($pingResult) {
                                $lat = $pingResult.ResponseTime
                                try {
                                    $dnsResult = Resolve-DnsName -Name $DnsTestDomain -Server $server -Type A -ErrorAction Stop
                                    if ($dnsResult.IPAddress) {
                                        Write-Host ("{0} (ping OK {1} ms) - Résolution DNS : OK" -f $server,$lat) -ForegroundColor Green
                                    } else {
                                        Write-Host ("{0} (ping OK {1} ms) - Résolution DNS : FAIL" -f $server,$lat) -ForegroundColor Yellow
                                    }
                                }
                                catch {
                                    Write-Host ("{0} (ping OK {1} ms) - Résolution DNS : FAIL" -f $server,$lat) -ForegroundColor Red
                                }
                            } else {
                                Write-Host ("{0} (ping FAIL)" -f $server) -ForegroundColor Red
                            }
                        }
                        catch {
                            Write-Host ("{0} (erreur de test)" -f $server) -ForegroundColor Yellow
                        }
                    }
                }
                Write-Host ""
            }
        }
    } else {
        Write-Host "Aucune interface réseau active détectée." -ForegroundColor Yellow
    }

    # Liste des cartes non connectées
        $disconnectedNics = Get-NetAdapter | Where-Object { $_.Status -eq "Disconnected" }
        if ($disconnectedNics) {
            Write-Host "Cartes réseau non connectées :" -ForegroundColor Cyan
            foreach ($dc in $disconnectedNics) {
                Write-Host (" - {0} ({1})" -f $dc.Name, $dc.InterfaceDescription) -ForegroundColor DarkGray
            }
        }

    Write-Host "`nVérification des suffixes DNS globaux" -ForegroundColor Cyan

try {
    $globalSuffixes = (Get-DnsClientGlobalSetting).SuffixSearchList
    if ($globalSuffixes -and $globalSuffixes.Count -gt 0) {
        Write-Host "Un ou plusieurs suffixes DNS globaux sont configurés :" -ForegroundColor Yellow
        $globalSuffixes | ForEach-Object {
            Write-Host (" - {0}" -f $_) -ForegroundColor DarkGray
        }
    } else {
        Write-Host "Aucun suffixe DNS global n'est configuré." -ForegroundColor DarkGray
    }
}
catch {
    Write-Host "Impossible de lire la configuration DNS globale." -ForegroundColor Red
}

    # === TESTS INTERNET ===
    Write-Host "`n=== Tests de connectivité Internet ===" -ForegroundColor Cyan
    $targets = @("8.8.8.8","www.google.ch")

    foreach ($target in $targets) {
        try {
            $remoteIP = $target
            if ($target -notmatch '^\d{1,3}(\.\d{1,3}){3}$') {
                try {
                    $resolved = [System.Net.Dns]::GetHostAddresses($target) | Where-Object { $_.AddressFamily -eq 'InterNetwork' } | Select-Object -First 1
                    if ($resolved) { $remoteIP = $resolved.IPAddressToString }
                } catch { }
            }

            $result = Test-Connection -ComputerName $remoteIP -Count 4 -ErrorAction SilentlyContinue
            if ($result) {
                $avg = [math]::Round(($result | Measure-Object ResponseTime -Average).Average,1)
                $route = Find-NetRoute -RemoteIPAddress $remoteIP -ErrorAction SilentlyContinue | Sort-Object RouteMetric | Select-Object -First 1
                if ($route) {
                    $nicUsed = (Get-NetAdapter -InterfaceIndex $route.InterfaceIndex -ErrorAction SilentlyContinue).Name
                    if (-not $nicUsed) { $nicUsed = "Interface $($route.InterfaceIndex)" }
                    Write-Host ("Ping {0,-15} : OK (via {1}, moyenne {2} ms)" -f $target,$nicUsed,$avg) -ForegroundColor Green
                }
                else {
                    Write-Host ("Ping {0,-15} : OK (interface inconnue, moyenne {1} ms)" -f $target,$avg) -ForegroundColor Yellow
                }
            }
            else {
                Write-Host ("Ping {0,-15} : FAIL" -f $target) -ForegroundColor Red
            }
        }
        catch {
            Write-Host ("Ping {0,-15} : Erreur de test" -f $target) -ForegroundColor Yellow
        }
    }
}
catch {
    Write-Host "Impossible de récupérer les infos réseau." -ForegroundColor Yellow
}


# --- Routes principales ---
Write-Host "`n=== Routes majeures (route print) ===" -ForegroundColor Cyan
try {
    $routes = Get-NetRoute -AddressFamily IPv4 | Where-Object {
        $_.DestinationPrefix -eq "0.0.0.0/0" -or
        $_.DestinationPrefix -like "10.*" -or
        $_.DestinationPrefix -like "172.1[6-9]*" -or
        $_.DestinationPrefix -like "172.2[0-9]*" -or
        $_.DestinationPrefix -like "172.3[0-1]*" -or
        $_.DestinationPrefix -like "192.168*"
    } | Sort-Object RouteMetric

    if ($routes) {
        $routes | ForEach-Object {
            Write-Host ("{0,-18} | {1,-18} | {2,-25} | Metric {3}" -f `
                $_.DestinationPrefix, $_.NextHop, $_.InterfaceAlias, $_.RouteMetric)
        }
    } else {
        Write-Host "Aucune route majeure détectée."
    }
}
catch { Write-Host "Impossible de récupérer les routes." -ForegroundColor Yellow }

# --- Extrait du fichier HOSTS ---
Write-Host "`n=== Extrait du fichier hosts ===" -ForegroundColor Cyan
try {
    $hosts = Get-Content "$env:SystemRoot\System32\drivers\etc\hosts" |
        Where-Object {$_ -match "^\s*[^#]" -and $_.Trim() -ne ""} |
        Select-Object -First 10
    if ($hosts) { $hosts | ForEach-Object { Write-Host $_ } }
    else { Write-Host "Aucune entrée personnalisée détectée." -ForegroundColor Green }
}
catch { Write-Host "Impossible de lire le fichier hosts." -ForegroundColor Yellow }

# ====================================================================
# QD - BLOC 4 : HEURE & NTP
# ====================================================================
Write-Host "`n=== Heure & NTP ===" -ForegroundColor Cyan
$LocalTime = Get-Date
Write-Host "Heure locale  : $LocalTime"

try {
    $ntpSource = (w32tm /query /source 2>&1)  # on capture aussi les erreurs
    if ($LASTEXITCODE -ne 0 -or $ntpSource -match "Acc.s refus.") {
        Write-Host "NTP Source    : Non accessible (droits admin requis)" -ForegroundColor Yellow
    }
    elseif ($ntpSource) {
        Write-Host "NTP Source    : $ntpSource"
    }
    else {
        Write-Host "NTP Source    : Non disponible" -ForegroundColor Yellow
    }
}
catch {
    Write-Host "NTP Source    : Non accessible (droits admin requis)" -ForegroundColor Yellow
}


# ====================================================================
# QD - BLOC 5 : ADMINS LOCAUX
# ====================================================================
function Format-Text {
    param(
        [string]$text,
        [int]$max
    )
    if ([string]::IsNullOrEmpty($text)) { return "" }
    if ($text.Length -gt $max) {
        return $text.Substring(0, $max - 3) + "..."
    }
    else {
        return $text
    }
}

Write-Host "`n=== Administrateurs locaux ===" -ForegroundColor Cyan
try {
    $LocalAdmins = Get-LocalGroupMember -SID "S-1-5-32-544" -ErrorAction Stop

    if ($LocalAdmins) {
        # Vérifie la disponibilité du module ActiveDirectory
        $ADAvailable = Get-Module -ListAvailable -Name ActiveDirectory | ForEach-Object { $true }

        foreach ($adm in $LocalAdmins) {
            $name = $adm.Name
            $cls  = $adm.ObjectClass

            # Comptes inconnus (SID non résolu)
            if ($adm.Name -match "^S-1-5-") {
                $name = "[Inconnu] $($adm.Name)"
                $cls  = "SID non résolu"
            }

            # Détection des comptes désactivés (si AD et module dispo)
            if ($ADAvailable -and $adm.ObjectClass -eq 'User' -and $adm.PrincipalSource -eq 'ActiveDirectory') {
                try {
                    $user = Get-ADUser -Identity $adm.Name -Properties Enabled -ErrorAction Stop
                    if (-not $user.Enabled) {
                        $name += " [désactivé]"
                    }
                }
                catch {
                    # Ignorer les erreurs (compte non résolu ou pas dans AD)
                }
            }

            $nameFmt = Format-Text $name 45
            $clsFmt  = Format-Text $cls 20
            Write-Host ("{0,-45} | {1}" -f $nameFmt, $clsFmt)
        }
    }
    else {
        Write-Host "Aucun administrateur local trouvé." -ForegroundColor Green
    }
}
catch {
    Write-Host "Non accessible (droits administrateur requis)" -ForegroundColor Yellow
}

# ====================================================================
# QD - BLOC 6 : PARTAGES LOCAUX
# ====================================================================

Write-Host "`n=== Partages locaux définis sur cette machine ===" -ForegroundColor Cyan

try {
    $shares = Get-SmbShare | Where-Object { $_.Name -notin @("IPC$") }

    if ($shares) {
        foreach ($s in $shares) {
            $exists = Test-Path $s.Path
            if (-not $exists) {
                Write-Host ("{0,-20} {1}" -f $s.Name, $s.Path) -ForegroundColor Yellow
            }
            else {
                Write-Host ("{0,-20} {1}" -f $s.Name, $s.Path)
            }
        }
    }
    else {
        Write-Host "Aucun partage local trouvé." -ForegroundColor Green
    }
}
catch {
    Write-Host "Impossible de récupérer les partages locaux (droits requis ?)" -ForegroundColor Yellow
    if ($DebugMode) { Write-Host $_.Exception.Message -ForegroundColor DarkGray }
}

# ====================================================================
# QD - BLOC 6b : LECTEURS RÉSEAU CONNECTÉS
# ====================================================================

Write-Host "`n=== Lecteurs réseau montés (net use) ===" -ForegroundColor Cyan

try {
    $mappings = Get-SmbMapping -ErrorAction SilentlyContinue

    if ($mappings) {
        foreach ($m in $mappings) {
            Write-Host ("{0,-10} {1,-45} {2}" -f $m.LocalPath, $m.RemotePath, $m.Status)
        }
    }
    else {
        $raw = net use 2>$null
        $lines = $raw | Where-Object { $_ -match "^[A-Z]:" }

        if ($lines) {
            $lines | ForEach-Object {
                if ($_ -match "^(?<Lecteur>[A-Z]:)\s+(?<Cible>\\\\[^\s]+)\s+.*(?<Etat>OK|Déconnecté|Disconnected)$") {
                    Write-Host ("{0,-10} {1,-45} {2}" -f $matches['Lecteur'], $matches['Cible'], $matches['Etat'])
                }
            }
        }
        else {
            Write-Host "Aucun lecteur réseau actuellement connecté." -ForegroundColor white
        }
    }
}
catch {
    Write-Host "Impossible de récupérer les lecteurs réseau." -ForegroundColor Yellow
    if ($DebugMode) { Write-Host $_.Exception.Message -ForegroundColor DarkGray }
}



# ====================================================================
# QD - BLOC 7 : SESSIONS UTILISATEURS (locale / RDP)
# ====================================================================
Write-Host "`n=== Sessions Utilisateurs (locale / RDP) ===" -ForegroundColor Cyan

# --- Mode debug manuel (forçable)
$DebugMode = $false

try {
    # --- Détection si rôle RDS actif (multi-session)
    $isRDS = $false
    try {
        $tsKey = 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server'
        if (Test-Path $tsKey) {
            $isRDS = ((Get-ItemProperty -Path $tsKey).TSEnabled -eq 1)
        }
    } catch {}

    # --- Lecture fiable de qwinsta (ISE/console)
    $raw = cmd /c qwinsta 2>$null
    if (-not $raw) { throw "qwinsta n'a rien retourné" }

    # --- Parsing des sessions
    $sessions = $raw -split "`r?`n" |
        Where-Object { $_ -and ($_ -notmatch 'SESSIONNAME\s+USERNAME') } |
        ForEach-Object {
            $line = $_.TrimStart() -replace '^\>', ''
            if ($line -match '^\s*(\S+)\s+(\S*)\s+(\d+)\s+(\S+)') {
                [PSCustomObject]@{
                    SessionName = $matches[1]
                    User        = if ($matches[2]) { $matches[2] } else { '' }
                    ID          = [int]$matches[3]
                    State       = $matches[4]
                }
            }
        }

    # --- Sessions système attendues
    $expectedSystemSessions = @('services','console','rdp-tcp')

    # --- Détection des profils utilisateurs
    $profiles = Get-CimInstance Win32_UserProfile -ErrorAction Stop | Where-Object { $_.LocalPath } | ForEach-Object {
        $uname = $null
        try {
            $uname = (New-Object System.Security.Principal.SecurityIdentifier($_.SID)).Translate([System.Security.Principal.NTAccount]).Value.Split('\')[-1]
        } catch {}
        [PSCustomObject]@{
            UserName  = $uname
            LocalPath = $_.LocalPath
            IsTemp    = $_.Temporary
        }
    }

    # --- Détection FSLogix avancée
    $fslogixInstalled = $false
    $fslogixVhdPaths = @()
    try {
        $regKey = 'HKLM:\SOFTWARE\FSLogix\Profiles'
        if (Test-Path $regKey) {
            $fslogixInstalled = $true
            $locations = (Get-ItemProperty -Path $regKey -ErrorAction Stop).VHDLocations
            if ($locations) {
                $locations -split ';' | ForEach-Object {
                    if (Test-Path $_) {
                        $fslogixVhdPaths += Get-ChildItem -Path $_ -Filter '*.vhdx' -ErrorAction SilentlyContinue
                    }
                }
            }
        }
    } catch { }

    # --- Filtrer les sessions utilisateur (pas les systèmes)
    $userSessions = $sessions | Where-Object {
        $_.SessionName -notin @('services','rdp-tcp') -and $_.User -ne ''
    }

    # --- Affichage principal
    if ($userSessions) {
        "{0,-15} {1,-30} {2,-5} {3,-12} {4}" -f "Session", "Utilisateur", "ID", "État", "Profil"
        Write-Host ("-" * 90)

        foreach ($s in $userSessions) {
            # Couleur par état
            if ($s.State -match '^(?i)acti|conn') { $color = 'Green' }
            elseif ($s.State -match '^(?i)disco') { $color = 'Yellow' }
            else { $color = 'Gray' }

            # Type de profil
            $profile = $profiles | Where-Object { $_.UserName -ieq $s.User } | Select-Object -First 1
            $profileType = 'Inconnu'

            if ($profile) {
                if ($profile.IsTemp) {
                    $profileType = 'Temporaire'
                    $color = 'Red'
                    if ($fslogixInstalled) {
                        Write-Host ("   Alerte : FSLogix installé mais profil temporaire détecté pour $($s.User)") -ForegroundColor Red
                    }
                }
                elseif ($profile.LocalPath -match '^\\\\') {
                    $profileType = 'Redirigé'
                }
                elseif ($profile.LocalPath -match '(FSLogix|\.vhdx)') {
                    $profileType = 'FSLogix'
                }
                elseif ($fslogixVhdPaths | Where-Object { $_.Name -match [regex]::Escape($s.User) }) {
                    $profileType = 'FSLogix'
                }
                else {
                    $profileType = 'Local'
                }
            }

            Write-Host ("{0,-15} {1,-30} {2,-5} {3,-12} {4}" -f $s.SessionName, $s.User, $s.ID, $s.State, $profileType) -ForegroundColor $color
        }
    } else {
        Write-Host "Aucune session utilisateur active." -ForegroundColor DarkGray
    }

    # --- Vérification sessions système manquantes (seulement si RDS)
    $missing = @()
    if ($isRDS) {
        $foundSystemSessions = $sessions.SessionName | Where-Object { $_ -in $expectedSystemSessions }
        $missing = $expectedSystemSessions | Where-Object { $_ -notin $foundSystemSessions }

        if ($missing) {
            Write-Host "`nSessions système manquantes :" -ForegroundColor Red
            foreach ($m in $missing) {
                Write-Host "   $m (session système éteinte !)" -ForegroundColor Red
            }
            $DebugMode = $true
        }
    }

    # --- Vérification des sessions "fantômes"
    if ($isRDS) {
        $explorerSessions = Get-Process -Name explorer -ErrorAction SilentlyContinue | Select-Object -ExpandProperty SessionId -Unique
        $ghostSessions = $sessions | Where-Object { $_.ID -notin $explorerSessions -and $_.User -ne '' }
        if ($ghostSessions) {
            Write-Host "`nSessions fantômes détectées (pas d'explorer.exe actif) :" -ForegroundColor Red
            foreach ($g in $ghostSessions) {
                Write-Host ("   {0} ({1}) - {2}" -f $g.User, $g.SessionName, $g.State) -ForegroundColor Red
            }
        }
    }

    # --- Vérification des profils FSLogix verrouillés
    if ($fslogixInstalled -and $fslogixVhdPaths) {
        $lockFiles = @()
        foreach ($path in ($fslogixVhdPaths | Select-Object -ExpandProperty DirectoryName -Unique)) {
            $lockFiles += Get-ChildItem -Path $path -Filter '*.lock' -ErrorAction SilentlyContinue
        }

        if ($lockFiles) {
            $activeUsers = $userSessions.User
            $lockedOrphans = $lockFiles | Where-Object {
                $name = $_.BaseName -replace '\.vhdx$', ''
                $activeUsers -notcontains $name
            }

            if ($lockedOrphans) {
                Write-Host "`nProfils FSLogix verrouillés sans session active :" -ForegroundColor Red
                foreach ($lock in $lockedOrphans) {
                    Write-Host ("   {0}" -f $lock.FullName) -ForegroundColor Red
                }
            }
        }
    }

    # --- Mode Debug étendu : affiche aussi les sessions système
    if ($DebugMode -and $sessions) {
        Write-Host "`n=== Sessions Système (debug) ===" -ForegroundColor DarkCyan
        foreach ($sys in $sessions | Where-Object { $_.SessionName -in $expectedSystemSessions }) {
            $sysUser = if ($sys.User) { $sys.User } else { '<n/a>' }
            Write-Host ("{0,-15} {1,-30} {2,-5} {3,-12}" -f $sys.SessionName, $sysUser, $sys.ID, $sys.State) -ForegroundColor DarkGray
        }
    }

}
catch {
    Write-Host "Impossible de récupérer les sessions : $($_.Exception.Message)" -ForegroundColor Yellow
}


# ====================================================================
# QD - BLOC 8a : SANTE MATERIEL & RESSOURCES
# ====================================================================
Write-Host "`n=== Santé Matériel & Ressources ===" -ForegroundColor Cyan

# --- CPU : moyenne courte ---
try {
    $cpuSamples = Get-Counter '\Processor(_Total)\% Processor Time' -SampleInterval 1 -MaxSamples 3 -ErrorAction Stop
    $cpuAvg = ($cpuSamples.CounterSamples.CookedValue | Measure-Object -Average).Average
    $cpuAvg = [math]::Round($cpuAvg,1)
    Write-Host ("CPU Utilisation : {0:N1} %" -f $cpuAvg)
}
catch {
    try {
        $cpuAvg = (Get-CimInstance Win32_Processor | Measure-Object -Property LoadPercentage -Average).Average
        if ($cpuAvg -ne $null) {
            Write-Host ("CPU Utilisation (approx.) : {0:N1} %" -f $cpuAvg)
        }
        else { #madebynico avec IA
            Write-Host "CPU Utilisation : Indisponible" -ForegroundColor Yellow
        }
    }
    catch {
        Write-Host "CPU Utilisation : Indisponible" -ForegroundColor Yellow
    }
}

# ====================================================================
# QD - BLOC 8b : SANTE MEMOIRE (RAM + SWAP)
# ====================================================================
Write-Host "`n=== Mémoire (RAM + Paging File) ===" -ForegroundColor Cyan

try {
    # --- RAM physique ---
    $ram = Get-CimInstance Win32_OperatingSystem
    $ramFreeGB  = [math]::Round($ram.FreePhysicalMemory/1MB,2)
    $ramTotalGB = [math]::Round($ram.TotalVisibleMemorySize/1MB,2)
    $ramUsedGB  = [math]::Round($ramTotalGB - $ramFreeGB,2)
    $ramPctFree = [math]::Round(($ramFreeGB / $ramTotalGB) * 100,1)

    $color = if ($ramPctFree -ge 30) { "Green" } elseif ($ramPctFree -ge 15) { "Yellow" } else { "Red" }
    Write-Host ("RAM Utilisation : {0} / {1} Go (Libre: {2} Go - {3}%)" -f $ramUsedGB, $ramTotalGB, $ramFreeGB, $ramPctFree) -ForegroundColor $color
}
catch {
    Write-Host "RAM Utilisation : Non accessible" -ForegroundColor Yellow
}

try {
    # --- Paging file (via CIM) ---
    $pageFiles = Get-CimInstance Win32_PageFileUsage
    if ($pageFiles) {
        foreach ($pf in $pageFiles) {
            $pct = [math]::Round(($pf.CurrentUsage / $pf.AllocatedBaseSize) * 100,1)
            $color = if ($pct -lt 50) { "Green" } elseif ($pct -lt 80) { "Yellow" } else { "Red" }
            Write-Host ("Fichier d’échange ({0}) : {1} Mo / {2} Mo ({3}%)" -f $pf.Name, $pf.CurrentUsage, $pf.AllocatedBaseSize, $pct) -ForegroundColor $color
        }
    }
    else {
        Write-Host "Fichier d’échange : Non configuré" -ForegroundColor Yellow
    }
}
catch {#Mouhahaha
    Write-Host "Fichier d’échange : Non accessible" -ForegroundColor Yellow
}

# 8c Disques (avec indicateur)

try {
    Get-PSDrive -PSProvider FileSystem | ForEach-Object {
        $pctUsed  = [math]::Round(($_.Used / ($_.Used + $_.Free)) * 100,1)
        $freeGB   = [math]::Round($_.Free / 1GB,1)
        $totalGB  = [math]::Round(($_.Used + $_.Free) / 1GB,1)
        $msg = ("Disque {0} : {1} / {2} Go libres ({3}% utilisé)" -f `
                $_.Name, $freeGB, $totalGB, $pctUsed)

        if ($pctUsed -lt 70) { # -=NG=-.
            Write-Host $msg -ForegroundColor Green   # espace suffisant
        }
        elseif ($pctUsed -lt 90) {
            Write-Host $msg -ForegroundColor Yellow  # à surveiller
        }
        else {
            Write-Host $msg -ForegroundColor Red     # critique
        }
    }
}
catch {
    Write-Host "Stockage : Non accessible" -ForegroundColor Yellow
}

# ====================================================================
# QD - BLOC 9 : SECURITE
# ====================================================================
Write-Host "`n=== Sécurité ===" -ForegroundColor Cyan
Write-Host "ne détecte que le statut de Windows Defender" -ForegroundColor Gray
try {
    $av = Get-MpComputerStatus -ErrorAction SilentlyContinue
    if ($av) { Write-Host "Antivirus (Defender) : $($av.AntivirusEnabled)" }
    else { Write-Host "Antivirus : Non accessible" -ForegroundColor Yellow }
}
catch { Write-Host "Antivirus : Non accessible (droits admin requis)" -ForegroundColor Yellow }

(Get-NetFirewallProfile) | ForEach-Object {
    Write-Host "Pare-feu $($_.Name) : $($_.Enabled)" #ghostscripteur
}

try {
    $bl = Get-BitLockerVolume -ErrorAction SilentlyContinue | Where-Object {$_.VolumeType -eq "OperatingSystem"}
    if ($bl) { Write-Host "BitLocker : $($bl.ProtectionStatus)" }
    else { Write-Host "BitLocker : Non disponible" }
}
catch { Write-Host "BitLocker : Non accessible (droits admin requis)" -ForegroundColor Yellow }


# ====================================================================
# QD - BLOC 10 : SERVICES (CRITIQUES + AUTRES)
# ====================================================================

function Format-Text {
    param($text, $max)
    if ($null -eq $text) { return "" }
    if ($text.Length -gt $max) {
        return $text.Substring(0, $max-3) + "..."
    } else {
        return $text
    }
}

Write-Host "`n=== Services Critiques Windows (OFF) ===" -ForegroundColor Cyan
$CriticalServices = @(
    "wuauserv","Dnscache","LanmanWorkstation","LanmanServer","EventLog","Schedule","WinRM",
    "TermService","SessionEnv","UmRdpService","Spooler",
    "NTDS","Netlogon","DFSR","KDC","DNS","DHCPServer","WINS",
    "W32Time","BITS","SamSs","WinDefend"
)

try {
    $CriticalStopped = Get-Service | Where-Object {
        $_.StartType -eq "Automatic" -and $_.Status -ne "Running" -and
        ($CriticalServices -contains $_.Name)
    } #des commentaires
    if ($CriticalStopped) {
        foreach ($svc in $CriticalStopped) { #nico avec GPT
            $name  = Format-Text $svc.Name 15
            $dname = Format-Text $svc.DisplayName 40
            Write-Host ("{0,-15} | {1,-40} | {2}" -f $name, $dname, $svc.Status)
        }
    } else {
        Write-Host "Tous les services critiques Windows sont démarrés." -ForegroundColor Green
    }
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }

Write-Host "`n=== Autres Services Automatiques (OFF) ===" -ForegroundColor Cyan
try {
    $OtherStopped = Get-Service | Where-Object {
        $_.StartType -eq "Automatic" -and $_.Status -ne "Running" -and
        ($CriticalServices -notcontains $_.Name)
    }
    if ($OtherStopped) { #madebymoi with someonebetterthanme
        foreach ($svc in $OtherStopped) {
            $name  = Format-Text $svc.Name 15
            $dname = Format-Text $svc.DisplayName 40
            Write-Host ("{0,-15} | {1,-40} | {2}" -f $name, $dname, $svc.Status)
        }
        Write-Host "⚠️ Vérifier si ces services métiers doivent être démarrés." -ForegroundColor Yellow
    } else {
        Write-Host "Aucun autre service automatique arrêté." -ForegroundColor Green
    }
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }




# ====================================================================
# QD - BLOC 11a : WINDOWS UPDATE
# ====================================================================
Write-Host "`n=== Windows Update ===" -ForegroundColor Cyan
try {
    $WUReboot = Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired"
    if ($WUReboot) { Write-Host "⚠️ Redémarrage en attente !" -ForegroundColor Red }
    else { Write-Host "Pas de redémarrage en attente." -ForegroundColor Green }
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }


# ====================================================================
# QD - BLOC 11c : FICHIERS PST / OST (taille & emplacement)
# ====================================================================
Write-Host "`n=== Fichiers Outlook PST / OST ===" -ForegroundColor Cyan

# Dossiers standards utilisés par Outlook (profil courant uniquement)
$paths = @(
    "$env:USERPROFILE\AppData\Local\Microsoft\Outlook",
    "$env:USERPROFILE\Documents\Outlook Files"
)

try {
    $files = @()

    foreach ($p in $paths) {
        if (Test-Path $p) {
            $found = Get-ChildItem -Path $p -Include *.ost, *.pst -Recurse -ErrorAction SilentlyContinue
            if ($found) { $files += $found }
        }
    }

    if ($files.Count -gt 0) {

        foreach ($f in $files) {
            $tailleGo = [math]::Round($f.Length / 1e9, 2)

            if ($tailleGo -ge 45) {
                $color = 'Red'
                $niveau = '⚠️ Critique'
            }
            elseif ($tailleGo -ge 35) {
                $color = 'Yellow'
                $niveau = 'Attention'
            }
            else {
                $color = 'Green'
                $niveau = 'OK'
            }

            Write-Host ("{0,-80} {1,8} Go   {2}" -f $f.FullName, $tailleGo, $niveau) -ForegroundColor $color
        }
    }
    else {
        Write-Host "Aucun fichier PST/OST trouvé dans le profil courant." -ForegroundColor Yellow
    }
}
catch {
    Write-Host "⚠️ Erreur lors du scan des fichiers PST/OST : $($_.Exception.Message)" -ForegroundColor Red
}

# ====================================================================
# QD - BLOC 11d : DOSSIERS SYSTÈME UTILES (taille racine uniquement)
# ====================================================================
Write-Host "`n=== Dossiers système utiles ===" -ForegroundColor Cyan

# Détection si Admin (pour SoftwareDistribution, WinSxS etc.)
$IsAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)

$folders = @(
    $env:TEMP,
    "$env:SystemRoot\SoftwareDistribution\Download",
    "$env:SystemRoot\Temp",
    "$env:SystemRoot\Logs",
    "$env:SystemRoot\WinSxS",
    "$env:LOCALAPPDATA\Temp"
)

foreach ($folder in $folders) {
    try {
        if (-not (Test-Path $folder)) {
            Write-Host ("{0,-60} | Non trouvé" -f $folder) -ForegroundColor Yellow
            continue
        }

        # Garde-fou : certains dossiers nécessitent admin
        if (($folder -like "$env:SystemRoot\*") -and -not $IsAdmin) {
            Write-Host ("{0,-60} | Accès refusé (non admin)" -f $folder) -ForegroundColor Yellow
            continue
        }

        $files = Get-ChildItem -Path $folder -File -ErrorAction SilentlyContinue
        $count = $files.Count
        $sizeMB = [math]::Round(($files | Measure-Object Length -Sum).Sum / 1MB, 1)
        Write-Host ("{0,-60} | {1,5} fichiers | {2,8} Mo" -f $folder, $count, $sizeMB)
    }
    catch {
        Write-Host ("{0,-60} | Erreur d'accès" -f $folder) -ForegroundColor Red
    }
}


# ====================================================================
# QD - BLOC 11e : APPLICATIONS INSTALLÉES (enrichies)
# ====================================================================
Write-Host "`n=== Inventaire des applications (HKLM + HKCU) ===" -ForegroundColor Cyan

$regPaths = @(
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*",
    "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*",
    "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*"
)

$apps = foreach ($path in $regPaths) {
    if (Test-Path $path) {
        Get-ItemProperty $path -ErrorAction SilentlyContinue | Where-Object {
            $_.DisplayName -and $_.DisplayName.Trim() -ne ""
        } | Select-Object `
            @{Name="Nom";Expression={$_.DisplayName}},
            @{Name="Version";Expression={$_.DisplayVersion}},
            @{Name="Editeur";Expression={$_.Publisher}},
            @{Name="Type";Expression={
                if ($_.DisplayName -match "Runtime|Redistributable|Host|WebView2") {"Runtime"}
                elseif ($_.DisplayName -match "Microsoft (Edge|Office|OneDrive|Teams)") {"System"}
                else {"UserApp"}
            }},
            @{Name="DateInstall";Expression={$_.InstallDate}},
            @{Name="Taille(MB)";Expression={if ($_.EstimatedSize) {[math]::Round($_.EstimatedSize/1024,1)}}},
            @{Name="Chemin";Expression={$_.InstallLocation}},
            @{Name="Source";Expression={$path.Split("\")[0]}}
    }
}

if ($apps) {
    $apps = $apps | Sort-Object Nom, Version -Unique
    Write-Host "Total : $($apps.Count) applications détectées.`n" -ForegroundColor Green
    $apps | Format-Table -AutoSize
}
else {
    Write-Host "Aucune application trouvée." -ForegroundColor Yellow
}


# ====================================================================
# QD - BLOC 12 : EVENT VIEWER (24 dernières heures) - Compact & Aligné
# ====================================================================
Write-Host "`n=== Analyse Event Viewer (24 dernières heures) ===" -ForegroundColor Cyan
$IsAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)

if (-not $IsAdmin) {
    Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow
} else {
    $Since = (Get-Date).AddHours(-24)
    $MainLogs = @("System","Application","Security","Setup")

    # Limite à 300 events par log pour performance
    $Events24h = foreach ($log in $MainLogs) {
        Get-WinEvent -FilterHashtable @{LogName=$log; StartTime=$Since} -MaxEvents 300 -ErrorAction SilentlyContinue
    }

    $CountCritical = ($Events24h | Where-Object { $_.Level -eq 1 }).Count
    $CountError    = ($Events24h | Where-Object { $_.Level -eq 2 }).Count #par ci et par là

    Write-Host "Critiques (24h): $CountCritical"
    Write-Host "Erreurs   (24h): $CountError"
    Write-Host "--- 10 dernières ERREURS ---" -ForegroundColor Yellow

    $LastErrors = $Events24h |
        Where-Object { $_.Level -eq 2 } |
        Sort-Object TimeCreated -Descending |
        Select-Object -First 10 TimeCreated, ProviderName, LogName, Message

    foreach ($err in $LastErrors) {
        # Message propre = 1 ligne, tronqué à 120 caractères
        $msg = ($err.Message -replace '\r?\n',' ' -replace '\s+',' ').Trim()
        if ($msg.Length -gt 120) { $msg = $msg.Substring(0,120) + "..." }

        # Colonnes fixes : Source=40, Log=15
        Write-Host ("[{0:dd.MM.yyyy HH:mm:ss}] | Source:{1,-40} | Log:{2,-15} | {3}" -f `
            $err.TimeCreated, $err.ProviderName, $err.LogName, $msg)
    }
}


# ====================================================================
# QD - BLOC 13 : SANTE MATERIEL - TEMPERATURE CPU
# ====================================================================
Write-Host "`n=== Température CPU ===" -ForegroundColor Cyan
try {
    $temps = Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace root/wmi -ErrorAction Stop
    $zonesUtiles = $temps | Where-Object { $_.InstanceName -match "CPU|GFX|PCH" }
    if ($zonesUtiles) {
        foreach ($t in $zonesUtiles) {
            $celsius = ($t.CurrentTemperature / 10) - 273.15
            $msg = ("Zone: {0,-20} | Temp: {1,5:N1} °C" -f $t.InstanceName, $celsius)
            if ($celsius -lt 60) { Write-Host $msg -ForegroundColor Green }
            elseif ($celsius -lt 80) { Write-Host $msg -ForegroundColor Yellow }
            else { Write-Host $msg -ForegroundColor Red }
        }
    } else {
        Write-Host "Non disponible (pas de capteur)" -ForegroundColor Yellow
    }
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }

# ====================================================================
# QD - BLOC 14 : PERIPHERIQUES EN ERREUR (CRITIQUES UNIQUEMENT)
# ====================================================================
Write-Host "`n=== Périphériques en erreur (drivers) ===" -ForegroundColor Cyan
try {
    $badDevices = Get-CimInstance  Win32_PnPEntity | Where-Object { $_.ConfigManagerErrorCode -ne 0 }
    if ($badDevices) {
        foreach ($dev in $badDevices) {#madebygruber
            Write-Host ("{0} | Code: {1}"  -f $dev.Name, $dev.ConfigManagerErrorCode)
        }
    } else {
        Write-Host "Aucun périphérique en erreur détecté." -ForegroundColor Green
    }
}
catch {
    Write-Host "Impossible de récupérer les périphériques." -ForegroundColor Yellow
}

# ====================================================================
# QD - BLOC 15 : POLITIQUES (AD GPO ou MDM Intune)
# ====================================================================
Write-Host "`n=== Politiques appliquées ===" -ForegroundColor Cyan

# Vérifie état de jonction
$dsreg = dsregcmd /status | Out-String
$aadJoined    = $dsreg -match "AzureAdJoined\s*:\s*(YES|OUI|JA)"
$domainJoined = $dsreg -match "DomainJoined\s*:\s*(YES|OUI|JA)"

if ($aadJoined) {
    Write-Host "Cet appareil est Azure AD Join : pas de GPO classiques." -ForegroundColor Yellow
    Write-Host "Les politiques proviennent d'Intune / MDM." -ForegroundColor DarkGray

    try {
        $mdmPolicies = Get-WinEvent -LogName Microsoft-Windows-DeviceManagement-Enterprise-Diagnostics-Provider/Admin |
                       Where-Object { $_.Message -like "*PolicyManager*" } |
                       Select-Object TimeCreated, Message |
                       Sort-Object TimeCreated -Descending |
                       Select-Object -First 15

        if ($mdmPolicies) {
            Write-Host "15 Dernières politiques MDM reçues (résumé)" -ForegroundColor Cyan
            foreach ($p in $mdmPolicies) {
                if ($p.Message -match "(Stratégie|Policy)\s*:\s*\((?<Strategy>.+?)\).*?(Zone|Area)\s*:\s*\((?<Zone>.+?)\)") {
                    $strategy = $matches['Strategy']
                    $zone     = $matches['Zone']
                    Write-Host ("[{0}] {1,-10} : {2}" -f $p.TimeCreated, $zone, $strategy) -ForegroundColor DarkGray
                }
                else {
                    Write-Host ("[{0}] {1}" -f $p.TimeCreated, $p.Message) -ForegroundColor DarkGray
                }
            }
        } else {
            Write-Host "Aucune politique MDM détectée dans les journaux." -ForegroundColor Yellow
        }
    }
    catch {
        Write-Host "Impossible de lire les politiques MDM." -ForegroundColor Red
    }
}
elseif ($domainJoined) {
    try {
        $domain = (Get-WmiObject Win32_ComputerSystem).Domain

        # Récupère le DC ayant répondu via nltest
        $dcInfo = nltest /dsgetdc:$domain 2>&1
        $dcResponding = ($dcInfo | Select-String "DC:").ToString().Split(":")[1].Trim()

        Write-Host "Cet appareil est Domain Join (AD)." -ForegroundColor Yellow
        Write-Host "Contrôleur ayant répondu : $dcResponding" -ForegroundColor Yellow
        Write-Host "Les politiques proviennent des GPO de l’Active Directory." -ForegroundColor DarkGray
    }
    catch {
        Write-Host "Cet appareil est Domain Join (AD), mais impossible de déterminer le contrôleur." -ForegroundColor Yellow
    }

    function Get-GPOFromGpresult {
        param([string]$Scope)

        try {
            $raw = gpresult /r /scope $Scope 2>&1 | Out-String

            if ($raw -match "Access Denied" -or $raw -match "Accès refusé" -or $raw -match "Zugriff verweigert") {
                return "ACCESS_DENIED"
            }

            # Motifs multilingues pour détecter début de la section
            $patternsStart = @(
                "Applied Group Policy Objects",
                "Objets de stratégie de groupe appliqués",
                "Angewendete Gruppenrichtlinienobjekte"
            )

            # Motifs multilingues pour détecter fin de section
            $patternsEnd = @(
                "The computer is a part of",      # EN
                "The user is a part of",
                "L'ordinateur fait partie",       # FR
                "L'utilisateur fait partie",
                "Der Computer ist Mitglied",      # DE
                "Der Benutzer ist Mitglied"
            )

            $lines = $raw -split "`r?`n"
            $capture = $false
            $gpos = @()

            foreach ($line in $lines) {
                if (-not $capture -and ($patternsStart | Where-Object { $line -match $_ })) {
                    $capture = $true
                    continue
                }

                if ($capture -and ($patternsEnd | Where-Object { $line -match $_ })) {
                    break
                }

                if ($capture) {
                    $trimmed = $line.Trim()
                    # On ignore les séparateurs et les lignes "Filtering:"
                    if ($trimmed -and ($trimmed -notmatch "^-+$") -and ($trimmed -notmatch "Filtering")) {
                        $gpos += $trimmed
                    }
                }
            }
            return $gpos
        }
        catch {
            return "ERROR"
        }
    }

    # --- Côté ordinateur ---
    Write-Host "`n--- Côté Ordinateur ---" -ForegroundColor Cyan
    $compGPOs = Get-GPOFromGpresult -Scope computer
    if ($compGPOs -eq "ACCESS_DENIED") {
        Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow
    } elseif ($compGPOs -eq "ERROR") {
        Write-Host "Impossible de récupérer la liste des GPO." -ForegroundColor Red
    } elseif ($compGPOs.Count -gt 0) {
        foreach ($gpo in $compGPOs) {
            Write-Host (" - {0}" -f $gpo) -ForegroundColor DarkGray
        }
    } else {
        Write-Host "Aucune GPO détectée côté ordinateur." -ForegroundColor Yellow
    }

    # --- Côté utilisateur ---
    Write-Host "`n--- Côté Utilisateur ($env:USERNAME) ---" -ForegroundColor Cyan
    $userGPOs = Get-GPOFromGpresult -Scope user
    if ($userGPOs -eq "ACCESS_DENIED") {
        Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow
    } elseif ($userGPOs -eq "ERROR") {
        Write-Host "Impossible de récupérer la liste des GPO." -ForegroundColor Red
    } elseif ($userGPOs.Count -gt 0) {
        foreach ($gpo in $userGPOs) {
            Write-Host (" - {0}" -f $gpo) -ForegroundColor DarkGray
        }
    } else {
        Write-Host "Aucune GPO détectée côté utilisateur." -ForegroundColor Yellow
    }
}
else {
    try {
        $workgroup = (Get-WmiObject Win32_ComputerSystem).Domain
        Write-Host "Cet appareil n’est ni Domain Join ni Azure AD Join (Workgroup : $workgroup)." -ForegroundColor Yellow
        Write-Host "Seules les stratégies locales (gpedit.msc) s’appliquent." -ForegroundColor DarkGray
    }
    catch {
        Write-Host "Cet appareil est en Workgroup, mais impossible de déterminer le nom du groupe de travail." -ForegroundColor Yellow
    }
}


# ==================================================================================================================================================================================================================================================
# QD - FIN DU DIAGNOSTIC
# ==================================================================================================================================================================================================================================================
try {  Stop-Transcript | Out-Null}
catch { }

if ($rapportPath -ne $null) {
    Write-Host "`n`n`nRapport complet exporté vers : $rapportPath" -ForegroundColor Cyan}
else {   Write-Host "`n`n`nFin du diagnostic" -ForegroundColor Cyan}



