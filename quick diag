<#
Script PowerShell
Utilisé par Nicolas GRUBER - Tebicom | Généré avec l'aide de ChatGPT (OpenAI)
Date : 27.09.2025
Résumé : Pré-Diagnostic automatique complet Windows Server/Endpoint (user+admin compatible)
#>

cls

# To DO - récup taille profil utilisateur de merde 
# to DO - Group Policy was applied from:      ADDS01.ecoledesoins.lan
# TO DO - drivers - afficher date du pilote
# PRT - détecter les sous-comptes
# Drvier printer - détecter les drivers postérieur à 2022

# ====================================================================
# INITIALISATION : TRANSCRIPT GLOBAL
# ====================================================================
try { #madebymoi with GhostEngineer
    if ($MyInvocation.MyCommand.Path) {
        $ScriptPath  = Split-Path -Parent $MyInvocation.MyCommand.Path
        $rapportPath = Join-Path $ScriptPath ("Diagnostic-Windows-{0}.txt" -f (Get-Date -Format 'yyyyMMdd-HHmm'))
        Start-Transcript -Path $rapportPath -Force | Out-Null
    }
    else {
        Write-Host "⚠️ Script lancé depuis la console/ISE → Pas de chemin pour export." -ForegroundColor Yellow
        $rapportPath = $null
    }
}
catch {
    Write-Host "⚠️ Impossible de démarrer le transcript (erreur d’écriture)." -ForegroundColor Yellow
    $rapportPath = $null
}



# ====================================================================
# INIT : Mesure CPU en arrière-plan
# ====================================================================
$SampleInterval = 1   # secondes entre mesures
$SampleCount    = 10  # durée totale = 10s

$cpuJob = Start-Job -ScriptBlock {
    param($SampleInterval,$SampleCount)
    $samples = Get-Counter '\Processor(_Total)\% Processor Time' -SampleInterval $SampleInterval -MaxSamples $SampleCount
    $avg = ($samples.CounterSamples.CookedValue | Measure-Object -Average).Average
    [math]::Round($avg,1)
} -ArgumentList $SampleInterval,$SampleCount

Write-Host "Start script" -ForegroundColor Darkgray


cls

# ====================================================================
# BLOC 1 : INFOS SYSTEME
# ====================================================================
Write-Host "=== Diagnostic Complet Windows Server / Endpoint ===" -ForegroundColor Cyan
$FQDN = [System.Net.Dns]::GetHostByName(($env:computerName)).HostName
$OS   = Get-CimInstance Win32_OperatingSystem
$CS   = Get-CimInstance Win32_ComputerSystem
$BIOS = Get-CimInstance Win32_BIOS
$LastReboot = $OS.LastBootUpTime

function Get-WindowsRelease {
    param([string]$BuildNumber)
    switch ($BuildNumber) {
        {$_ -gt 26100} { return "Version trop récente pour le script (build $BuildNumber)" }
        {$_ -ge 26100} { return "24H2" }
        {$_ -ge 22631} { return "23H2" }
        {$_ -ge 22621} { return "22H2" }
        {$_ -ge 22000} { return "21H2" }
        {$_ -ge 19045} { return "22H2 (Win10)" }
        {$_ -ge 19044} { return "21H2 (Win10)" }
        default { return "Inconnu ($BuildNumber)" }
    }
}
$Release = Get-WindowsRelease -BuildNumber $OS.BuildNumber

# Recherche de la dernière mise à jour installée avec parsing robuste
$LastWU = Get-WmiObject -Class "Win32_QuickFixEngineering" |
          Where-Object { $_.InstalledOn -ne $null -and $_.InstalledOn -ne "" } |
          Sort-Object {
              if ($_.InstalledOn -is [datetime]) {
                  $_.InstalledOn
              } else {
                  [datetime]::Parse($_.InstalledOn)
              }
          } -Descending |
          Select-Object -First 1

if ($LastWU) {
    $DateMAJ = if ($LastWU.InstalledOn -is [datetime]) {
        $LastWU.InstalledOn
    } else {
        [datetime]::Parse($LastWU.InstalledOn)
    }

    # Format clair FR (mois en toutes lettres)
    $LastUpdateFmt = $DateMAJ.ToString("dd MMMM yyyy HH:mm:ss", [System.Globalization.CultureInfo]::GetCultureInfo("fr-FR"))
    $LastUpdateStr = "$LastUpdateFmt ($($LastWU.HotFixID))"
} else {
    $LastUpdateStr = "Non trouvé"
}

# Format ISO pour reboot
$LastRebootFmt  = $LastReboot.ToString("yyyy-MM-dd HH:mm:ss")

# Affichage aligné
Write-Host ("{0,-22}: {1}" -f "Nom FQDN", $FQDN)
Write-Host ("{0,-22}: {1} {2}" -f "OS Version", $OS.Caption, $Release)
Write-Host ("{0,-22}: {1}" -f "Dernière MAJ", $LastUpdateStr)
Write-Host ("{0,-22}: {1}" -f "Dernier reboot", $LastRebootFmt)
Write-Host ("{0,-22}: {1}" -f "Modèle", "$($CS.Manufacturer) $($CS.Model)")
Write-Host ("{0,-22}: {1}" -f "N° de série", $BIOS.SerialNumber)

# ====================================================================
# BLOC 2 : INTEGRATION ANNUAIRE & OAUTH LOCAL
# ====================================================================
Write-Host "`n=== Intégration annuaire / Azure AD / OAuth ===" -ForegroundColor Cyan
try {
    $cs = Get-CimInstance Win32_ComputerSystem
    $dsreg = dsregcmd /status 2>$null

    $aadJoin       = ($dsreg -match "AzureAdJoined\s*:\s*YES")
    $workplaceJoin = ($dsreg -match "WorkplaceJoined\s*:\s*YES")
    $prtActive     = ($dsreg -match "AzureAdPrt\s*:\s*YES")
    $domainJoin    = $cs.PartOfDomain
    
    try {
    $currentUPN = (whoami /upn 2>$null)
    if (-not $currentUPN) { $currentUPN = (whoami) }
    }
    catch {
        $currentUPN = (whoami)
    }


    if ($domainJoin -and -not $aadJoin) {
        Write-Host "État machine : Active Directory Join (domaine $($cs.Domain))" -ForegroundColor Green
        if ($currentUPN) { Write-Host "Utilisateur courant : $currentUPN" }
    }
    elseif ($aadJoin) {
        Write-Host "État machine : Azure AD Join" -ForegroundColor Green
        if ($currentUPN) { Write-Host "Utilisateur courant : $currentUPN" }
        if ($prtActive)  { Write-Host "PRT (SSO) : Actif" -ForegroundColor Green }
        else             { Write-Host "PRT (SSO) : Inactif" -ForegroundColor Red }
    }
    elseif ($workplaceJoin) { # -=NG=
        Write-Host "État machine : Workplace Join (Azure AD Registered)" -ForegroundColor Yellow
        if ($currentUPN) { Write-Host "Utilisateur courant : $currentUPN" }
    }
    else {
        Write-Host "État machine : Groupe de travail (Workgroup)" -ForegroundColor Red
        if ($currentUPN) { Write-Host "Utilisateur courant : $currentUPN" }
    }
}
catch {
    Write-Host "Non accessible (dsregcmd bloqué ou droits insuffisants)" -ForegroundColor Yellow
}


# ====================================================================
# BLOC 3 : RESEAU & CONNECTIVITE (corrigé avec Resolve-DnsName)
# ====================================================================
Write-Host "`n=== Réseau & Connectivité ===" -ForegroundColor Cyan

# Domaine utilisé pour tester la résolution DNS
$DnsTestDomain = "www.microsoft.com"
$DnsFallback   = "www.googe.ch"

Write-Host "(Résolution DNS testée sur $DnsTestDomain, fallback $DnsFallback)" -ForegroundColor DarkGray

# Test rapide si le domaine principal répond, sinon fallback
try {
    $testRes = Resolve-DnsName $DnsTestDomain -ErrorAction Stop
}
catch {
    Write-Host "⚠️ $DnsTestDomain ne répond pas, utilisation du fallback $DnsFallback" -ForegroundColor Yellow
    $DnsTestDomain = $DnsFallback
}

try {
    $nics = Get-NetAdapter | Where-Object { $_.Status -eq "Up" } | Sort-Object ifIndex
    if ($nics) {
        foreach ($nic in $nics) {
            $ips       = Get-NetIPAddress -InterfaceIndex $nic.ifIndex -AddressFamily IPv4 -ErrorAction SilentlyContinue
            $dns       = (Get-DnsClientServerAddress -InterfaceIndex $nic.ifIndex -AddressFamily IPv4 -ErrorAction SilentlyContinue).ServerAddresses
            $profile   = Get-NetConnectionProfile -InterfaceIndex $nic.ifIndex -ErrorAction SilentlyContinue
            $dnsClient = Get-DnsClient -InterfaceIndex $nic.ifIndex -ErrorAction SilentlyContinue

            # Récupération de la passerelle via route 0.0.0.0/0
            $gw = (Get-NetRoute -InterfaceIndex $nic.ifIndex -DestinationPrefix "0.0.0.0/0" -ErrorAction SilentlyContinue).NextHop

            foreach ($ip in $ips) {
                Write-Host ("Interface {0} ({1})" -f $nic.Name, $nic.InterfaceDescription) -ForegroundColor Cyan
                Write-Host ("Adresse IP    : {0}/{1}" -f $ip.IPAddress, $ip.PrefixLength)
                Write-Host ("Adresse MAC   : {0}" -f $nic.MacAddress)

                if ($profile) {
                    Write-Host ("Profil réseau : {0}" -f $profile.NetworkCategory)
                }

                if ($dnsClient -and $dnsClient.ConnectionSpecificSuffix) {
                    Write-Host ("Suffixe DNS   : {0}" -f $dnsClient.ConnectionSpecificSuffix)
                }

                # DHCP ou statique
                if ($ip.AddressState -eq "Preferred") {
                    if ($ip.PrefixOrigin -eq "Dhcp") {
                        Write-Host "Mode IP       : DHCP"
                    } else {
                        Write-Host "Mode IP       : Statique"
                    }
                }

                # --- Passerelles
                if ($gw) {
                    foreach ($g in $gw) {
                        $pingGW = Test-Connection -ComputerName $g -Count 1 -Quiet -ErrorAction SilentlyContinue
                        if ($pingGW) { Write-Host ("Passerelle    : {0} (ping OK)" -f $g) -ForegroundColor Green }
                        else         { Write-Host ("Passerelle    : {0} (ping FAIL)" -f $g) -ForegroundColor Red }
                    }
                } else {
                    Write-Host "Passerelle    : (aucune ou inaccessible)" -ForegroundColor Yellow
                }

                # --- DNS
                if ($dns) {
                    Write-Host "Serveur DNS   :"
                    foreach ($server in $dns) {
                        try {
                            $pingResult = Test-Connection -ComputerName $server -Count 1 -ErrorAction SilentlyContinue
                            if ($pingResult) {
                                $lat = $pingResult.ResponseTime
                                try {
                                    $dnsResult = Resolve-DnsName -Name $DnsTestDomain -Server $server -Type A -ErrorAction Stop
                                    if ($dnsResult.IPAddress) {
                                        Write-Host ("{0} (ping OK {1} ms) - Résolution DNS : OK" -f $server,$lat) -ForegroundColor Green
                                    } else {
                                        Write-Host ("{0} (ping OK {1} ms) - Résolution DNS : FAIL" -f $server,$lat) -ForegroundColor Yellow
                                    }
                                }
                                catch {
                                    Write-Host ("{0} (ping OK {1} ms) - Résolution DNS : FAIL" -f $server,$lat) -ForegroundColor Red
                                }
                            } else {
                                Write-Host ("{0} (ping FAIL)" -f $server) -ForegroundColor Red
                            }
                        }
                        catch {
                            Write-Host ("{0} (erreur de test)" -f $server) -ForegroundColor Yellow
                        }
                    }
                }
                Write-Host ""
            }
        }
    } else {
        Write-Host "Aucune interface réseau active détectée." -ForegroundColor Yellow
    }

    # Liste des cartes non connectées
        $disconnectedNics = Get-NetAdapter | Where-Object { $_.Status -eq "Disconnected" }
        if ($disconnectedNics) {
            Write-Host "Cartes réseau non connectées :" -ForegroundColor Cyan
            foreach ($dc in $disconnectedNics) {
                Write-Host (" - {0} ({1})" -f $dc.Name, $dc.InterfaceDescription) -ForegroundColor DarkGray
            }
        }

    Write-Host "`nVérification des suffixes DNS globaux" -ForegroundColor Cyan

try {
    $globalSuffixes = (Get-DnsClientGlobalSetting).SuffixSearchList
    if ($globalSuffixes -and $globalSuffixes.Count -gt 0) {
        Write-Host "Un ou plusieurs suffixes DNS globaux sont configurés :" -ForegroundColor Yellow
        $globalSuffixes | ForEach-Object {
            Write-Host (" - {0}" -f $_) -ForegroundColor DarkGray
        }
    } else {
        Write-Host "Aucun suffixe DNS global n'est configuré." -ForegroundColor DarkGray
    }
}
catch {
    Write-Host "Impossible de lire la configuration DNS globale." -ForegroundColor Red
}

    # === TESTS INTERNET ===
    Write-Host "`n=== Tests de connectivité Internet ===" -ForegroundColor Cyan
    $targets = @("8.8.8.8","www.google.ch")

    foreach ($target in $targets) {
        try {
            $remoteIP = $target
            if ($target -notmatch '^\d{1,3}(\.\d{1,3}){3}$') {
                try {
                    $resolved = [System.Net.Dns]::GetHostAddresses($target) | Where-Object { $_.AddressFamily -eq 'InterNetwork' } | Select-Object -First 1
                    if ($resolved) { $remoteIP = $resolved.IPAddressToString }
                } catch { }
            }

            $result = Test-Connection -ComputerName $remoteIP -Count 4 -ErrorAction SilentlyContinue
            if ($result) {
                $avg = [math]::Round(($result | Measure-Object ResponseTime -Average).Average,1)
                $route = Find-NetRoute -RemoteIPAddress $remoteIP -ErrorAction SilentlyContinue | Sort-Object RouteMetric | Select-Object -First 1
                if ($route) {
                    $nicUsed = (Get-NetAdapter -InterfaceIndex $route.InterfaceIndex -ErrorAction SilentlyContinue).Name
                    if (-not $nicUsed) { $nicUsed = "Interface $($route.InterfaceIndex)" }
                    Write-Host ("Ping {0,-15} : OK (via {1}, moyenne {2} ms)" -f $target,$nicUsed,$avg) -ForegroundColor Green
                }
                else {
                    Write-Host ("Ping {0,-15} : OK (interface inconnue, moyenne {1} ms)" -f $target,$avg) -ForegroundColor Yellow
                }
            }
            else {
                Write-Host ("Ping {0,-15} : FAIL" -f $target) -ForegroundColor Red
            }
        }
        catch {
            Write-Host ("Ping {0,-15} : Erreur de test" -f $target) -ForegroundColor Yellow
        }
    }
}
catch {
    Write-Host "Impossible de récupérer les infos réseau." -ForegroundColor Yellow
}


# --- Routes principales ---
Write-Host "`n=== Routes majeures (route print) ===" -ForegroundColor Cyan
try {
    $routes = Get-NetRoute -AddressFamily IPv4 | Where-Object {
        $_.DestinationPrefix -eq "0.0.0.0/0" -or
        $_.DestinationPrefix -like "10.*" -or
        $_.DestinationPrefix -like "172.1[6-9]*" -or
        $_.DestinationPrefix -like "172.2[0-9]*" -or
        $_.DestinationPrefix -like "172.3[0-1]*" -or
        $_.DestinationPrefix -like "192.168*"
    } | Sort-Object RouteMetric

    if ($routes) {
        $routes | ForEach-Object {
            Write-Host ("{0,-18} | {1,-18} | {2,-25} | Metric {3}" -f `
                $_.DestinationPrefix, $_.NextHop, $_.InterfaceAlias, $_.RouteMetric)
        }
    } else {
        Write-Host "Aucune route majeure détectée."
    }
}
catch { Write-Host "Impossible de récupérer les routes." -ForegroundColor Yellow }

# --- Extrait du fichier HOSTS ---
Write-Host "`n=== Extrait du fichier hosts ===" -ForegroundColor Cyan
try {
    $hosts = Get-Content "$env:SystemRoot\System32\drivers\etc\hosts" |
        Where-Object {$_ -match "^\s*[^#]" -and $_.Trim() -ne ""} |
        Select-Object -First 10
    if ($hosts) { $hosts | ForEach-Object { Write-Host $_ } }
    else { Write-Host "Aucune entrée personnalisée détectée." -ForegroundColor Green }
}
catch { Write-Host "Impossible de lire le fichier hosts." -ForegroundColor Yellow }

# ====================================================================
# BLOC 4 : HEURE & NTP
# ====================================================================
Write-Host "`n=== Heure & NTP ===" -ForegroundColor Cyan
$LocalTime = Get-Date
Write-Host "Heure locale  : $LocalTime"

try {
    $ntpSource = (w32tm /query /source 2>&1)  # on capture aussi les erreurs
    if ($LASTEXITCODE -ne 0 -or $ntpSource -match "Acc.s refus.") {
        Write-Host "NTP Source    : Non accessible (droits admin requis)" -ForegroundColor Yellow
    }
    elseif ($ntpSource) {
        Write-Host "NTP Source    : $ntpSource"
    }
    else {
        Write-Host "NTP Source    : Non disponible" -ForegroundColor Yellow
    }
}
catch {
    Write-Host "NTP Source    : Non accessible (droits admin requis)" -ForegroundColor Yellow
}


# ====================================================================
# BLOC 5 : ADMINS LOCAUX
# ====================================================================
function Format-Text {
    param($text, $max)
    if ($null -eq $text) { return "" }
    if ($text.Length -gt $max) {
        return $text.Substring(0, $max-3) + "..."
    } else {
        return $text
    }
}

Write-Host "`n=== Administrateurs locaux ===" -ForegroundColor Cyan
try {
    $LocalAdmins = Get-LocalGroupMember -SID "S-1-5-32-544"
    if ($LocalAdmins) {
        foreach ($adm in $LocalAdmins) {
            $name = Format-Text $adm.Name 40
            $cls  = Format-Text $adm.ObjectClass 15
            Write-Host ("{0,-40} | {1}" -f $name, $cls)
        }
    }
    else {
        Write-Host "Aucun admin local trouvé."
    } #madebyngr with openai
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }


# ====================================================================
# BLOC 6a : PARTAGES LOCAUX
# ====================================================================
Write-Host "`n=== Partages locaux définis sur cette machine ===" -ForegroundColor Cyan
try {
    $shares = Get-SmbShare | Where-Object { $_.Name -notin @("IPC$") }
    if ($shares) {
        ($shares | Select-Object Name, Path, Description, ShareType | Format-Table -AutoSize | Out-String).Trim() | Write-Host
    }
    else {
        Write-Host "Aucun partage local trouvé." -ForegroundColor Green
    }
}
catch {
    Write-Host "Impossible de récupérer les partages locaux (droits requis ?)" -ForegroundColor Yellow
}

# ====================================================================
# BLOC 6b : LECTEURS RÉSEAU CONNECTÉS
# ====================================================================
Write-Host "`n=== Lecteurs réseau montés (net use) ===" -ForegroundColor Cyan
try {
    $mappings = Get-SmbMapping -ErrorAction SilentlyContinue

    if ($mappings) {
        ($mappings | Select-Object LocalPath, RemotePath, Status | Format-Table -AutoSize | Out-String).Trim() | Write-Host
    }
    else {
        $raw = net use 2>$null
        $lines = $raw | Where-Object { $_ -match "^[A-Z]:" }
        if ($lines) {# -=Nico-
            ($lines | ForEach-Object {
                $parts = ($_ -split "\s+") -ne ""
                [PSCustomObject]@{
                    Lecteur = $parts[0]
                    Cible   = $parts[1]
                    Etat    = $parts[-1]
                }
            } | Format-Table -AutoSize | Out-String).Trim() | Write-Host
        }
        else {
            Write-Host "Aucun lecteur réseau actuellement connecté." -ForegroundColor Green
        }
    }
}
catch {
    Write-Host "Impossible de récupérer les lecteurs réseau." -ForegroundColor Yellow
}


# ====================================================================
# BLOC 7 : SESSIONS UTILISATEURS (locale / RDP)
# ====================================================================
Write-Host "`n=== Sessions Utilisateurs (locale / RDP) ===" -ForegroundColor Cyan
try { # je cache 
    $sessions = (qwinsta) -split "`r?`n" | Where-Object {$_ -match "console|rdp"}
    $logons = Get-CimInstance Win32_LoggedOnUser | ForEach-Object {
        $u = $_.Antecedent.ToString()
        if ($u -match 'Domain="(.+)",Name="(.+)"') {
            [PSCustomObject]@{
                Domain = $matches[1]
                User   = $matches[2]
            }
        }
    }

    if ($sessions) {
        foreach ($s in $sessions) {
            $parts = ($s -split '\s+') -ne ''
            $sessionName = $parts[0]
            $userNT      = $parts[1]
            $id          = $parts[2]
            $state       = $parts[3]

            $resolved = $logons | Where-Object { $_.User -eq $userNT } | Select-Object -First 1
            if ($resolved) {
                $userDisplay = "$($resolved.User) ($($resolved.Domain))"
            } else {
                $userDisplay = $userNT
            }

            Write-Host ("{0,-20} {1,-35} {2,-3} {3}" -f $sessionName, $userDisplay, $id, $state)
        }
    } else {
        Write-Host "Aucune session détectée."
    }
}
catch {
    Write-Host "Impossible de récupérer les sessions." -ForegroundColor Yellow
}


# ====================================================================
# BLOC 8a : SANTE MATERIEL & RESSOURCES
# ====================================================================
Write-Host "`n=== Santé Matériel & Ressources ===" -ForegroundColor Cyan

# --- CPU : moyenne courte ---
try {
    $cpuSamples = Get-Counter '\Processor(_Total)\% Processor Time' -SampleInterval 1 -MaxSamples 3 -ErrorAction Stop
    $cpuAvg = ($cpuSamples.CounterSamples.CookedValue | Measure-Object -Average).Average
    $cpuAvg = [math]::Round($cpuAvg,1)
    Write-Host ("CPU Utilisation : {0:N1} %" -f $cpuAvg)
}
catch {
    try {
        $cpuAvg = (Get-CimInstance Win32_Processor | Measure-Object -Property LoadPercentage -Average).Average
        if ($cpuAvg -ne $null) {
            Write-Host ("CPU Utilisation (approx.) : {0:N1} %" -f $cpuAvg)
        }
        else { #madebynico avec IA
            Write-Host "CPU Utilisation : Indisponible" -ForegroundColor Yellow
        }
    }
    catch {
        Write-Host "CPU Utilisation : Indisponible" -ForegroundColor Yellow
    }
}

# ====================================================================
# BLOC 8b : SANTE MEMOIRE (RAM + SWAP)
# ====================================================================
Write-Host "`n=== Mémoire (RAM + Paging File) ===" -ForegroundColor Cyan

try {
    # --- RAM physique ---
    $ram = Get-CimInstance Win32_OperatingSystem
    $ramFreeGB  = [math]::Round($ram.FreePhysicalMemory/1MB,2)
    $ramTotalGB = [math]::Round($ram.TotalVisibleMemorySize/1MB,2)
    $ramUsedGB  = [math]::Round($ramTotalGB - $ramFreeGB,2)
    $ramPctFree = [math]::Round(($ramFreeGB / $ramTotalGB) * 100,1)

    $color = if ($ramPctFree -ge 30) { "Green" } elseif ($ramPctFree -ge 15) { "Yellow" } else { "Red" }
    Write-Host ("RAM Utilisation : {0} / {1} Go (Libre: {2} Go - {3}%)" -f $ramUsedGB, $ramTotalGB, $ramFreeGB, $ramPctFree) -ForegroundColor $color
}
catch {
    Write-Host "RAM Utilisation : Non accessible" -ForegroundColor Yellow
}

try {
    # --- Paging file (via CIM) ---
    $pageFiles = Get-CimInstance Win32_PageFileUsage
    if ($pageFiles) {
        foreach ($pf in $pageFiles) {
            $pct = [math]::Round(($pf.CurrentUsage / $pf.AllocatedBaseSize) * 100,1)
            $color = if ($pct -lt 50) { "Green" } elseif ($pct -lt 80) { "Yellow" } else { "Red" }
            Write-Host ("Fichier d’échange ({0}) : {1} Mo / {2} Mo ({3}%)" -f $pf.Name, $pf.CurrentUsage, $pf.AllocatedBaseSize, $pct) -ForegroundColor $color
        }
    }
    else {
        Write-Host "Fichier d’échange : Non configuré" -ForegroundColor Yellow
    }
}
catch {#Mouhahaha
    Write-Host "Fichier d’échange : Non accessible" -ForegroundColor Yellow
}

# 8c Disques (avec indicateur)

try {
    Get-PSDrive -PSProvider FileSystem | ForEach-Object {
        $pctUsed  = [math]::Round(($_.Used / ($_.Used + $_.Free)) * 100,1)
        $freeGB   = [math]::Round($_.Free / 1GB,1)
        $totalGB  = [math]::Round(($_.Used + $_.Free) / 1GB,1)
        $msg = ("Disque {0} : {1} / {2} Go libres ({3}% utilisé)" -f `
                $_.Name, $freeGB, $totalGB, $pctUsed)

        if ($pctUsed -lt 70) { # -=NG=-.
            Write-Host $msg -ForegroundColor Green   # espace suffisant
        }
        elseif ($pctUsed -lt 90) {
            Write-Host $msg -ForegroundColor Yellow  # à surveiller
        }
        else {
            Write-Host $msg -ForegroundColor Red     # critique
        }
    }
}
catch {
    Write-Host "Stockage : Non accessible" -ForegroundColor Yellow
}

# ====================================================================
# BLOC 9 : SECURITE
# ====================================================================
Write-Host "`n=== Sécurité ===" -ForegroundColor Cyan
Write-Host "ne détecte que le statut de Windows Defender" -ForegroundColor Gray
try {
    $av = Get-MpComputerStatus -ErrorAction SilentlyContinue
    if ($av) { Write-Host "Antivirus (Defender) : $($av.AntivirusEnabled)" }
    else { Write-Host "Antivirus : Non accessible" -ForegroundColor Yellow }
}
catch { Write-Host "Antivirus : Non accessible (droits admin requis)" -ForegroundColor Yellow }

(Get-NetFirewallProfile) | ForEach-Object {
    Write-Host "Pare-feu $($_.Name) : $($_.Enabled)" #ghostscripteur
}

try {
    $bl = Get-BitLockerVolume -ErrorAction SilentlyContinue | Where-Object {$_.VolumeType -eq "OperatingSystem"}
    if ($bl) { Write-Host "BitLocker : $($bl.ProtectionStatus)" }
    else { Write-Host "BitLocker : Non disponible" }
}
catch { Write-Host "BitLocker : Non accessible (droits admin requis)" -ForegroundColor Yellow }


# ====================================================================
# BLOC 10 : SERVICES (CRITIQUES + AUTRES)
# ====================================================================

function Format-Text {
    param($text, $max)
    if ($null -eq $text) { return "" }
    if ($text.Length -gt $max) {
        return $text.Substring(0, $max-3) + "..."
    } else {
        return $text
    }
}

Write-Host "`n=== Services Critiques Windows (OFF) ===" -ForegroundColor Cyan
$CriticalServices = @(
    "wuauserv","Dnscache","LanmanWorkstation","LanmanServer","EventLog","Schedule","WinRM",
    "TermService","SessionEnv","UmRdpService","Spooler",
    "NTDS","Netlogon","DFSR","KDC","DNS","DHCPServer","WINS",
    "W32Time","BITS","SamSs","WinDefend"
)

try {
    $CriticalStopped = Get-Service | Where-Object {
        $_.StartType -eq "Automatic" -and $_.Status -ne "Running" -and
        ($CriticalServices -contains $_.Name)
    } #des commentaires
    if ($CriticalStopped) {
        foreach ($svc in $CriticalStopped) { #nico avec GPT
            $name  = Format-Text $svc.Name 15
            $dname = Format-Text $svc.DisplayName 40
            Write-Host ("{0,-15} | {1,-40} | {2}" -f $name, $dname, $svc.Status)
        }
    } else {
        Write-Host "Tous les services critiques Windows sont démarrés." -ForegroundColor Green
    }
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }

Write-Host "`n=== Autres Services Automatiques (OFF) ===" -ForegroundColor Cyan
try {
    $OtherStopped = Get-Service | Where-Object {
        $_.StartType -eq "Automatic" -and $_.Status -ne "Running" -and
        ($CriticalServices -notcontains $_.Name)
    }
    if ($OtherStopped) { #madebymoi with someonebetterthanme
        foreach ($svc in $OtherStopped) {
            $name  = Format-Text $svc.Name 15
            $dname = Format-Text $svc.DisplayName 40
            Write-Host ("{0,-15} | {1,-40} | {2}" -f $name, $dname, $svc.Status)
        }
        Write-Host "⚠️ Vérifier si ces services métiers doivent être démarrés." -ForegroundColor Yellow
    } else {
        Write-Host "Aucun autre service automatique arrêté." -ForegroundColor Green
    }
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }




# ====================================================================
# BLOC 11a : WINDOWS UPDATE
# ====================================================================
Write-Host "`n=== Windows Update ===" -ForegroundColor Cyan
try {
    $WUReboot = Test-Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired"
    if ($WUReboot) { Write-Host "⚠️ Redémarrage en attente !" -ForegroundColor Red }
    else { Write-Host "Pas de redémarrage en attente." -ForegroundColor Green }
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }


# ====================================================================
# BLOC 11c : FICHIERS PST / OST (taille & emplacement)
# ====================================================================
Write-Host "`n=== Fichiers Outlook PST / OST ===" -ForegroundColor Cyan

# Dossiers standards utilisés par Outlook (profil courant uniquement)
$paths = @(
    "$env:USERPROFILE\AppData\Local\Microsoft\Outlook",
    "$env:USERPROFILE\Documents\Outlook Files"
)

try {
    $files = @()

    foreach ($p in $paths) {
        if (Test-Path $p) {
            $found = Get-ChildItem -Path $p -Include *.ost, *.pst -Recurse -ErrorAction SilentlyContinue
            if ($found) { $files += $found }
        }
    }

    if ($files.Count -gt 0) {
        $files | Select-Object FullName,@{Name="Taille (Go)";Expression={[math]::Round($_.Length / 1GB,2)}} | 
            Format-Table -AutoSize
    }
    else {
        Write-Host "Aucun fichier PST/OST trouvé dans le profil courant." -ForegroundColor Yellow
    }
} #ng
catch {
    Write-Host "⚠️ Erreur lors du scan des fichiers PST/OST : $($_.Exception.Message)" -ForegroundColor Red
}

# ====================================================================
# BLOC 11d : DOSSIERS SYSTÈME UTILES (taille racine uniquement)
# ====================================================================
Write-Host "`n=== Dossiers système utiles ===" -ForegroundColor Cyan

# Détection si Admin (pour SoftwareDistribution, WinSxS etc.)
$IsAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)

$folders = @(
    $env:TEMP,
    "$env:SystemRoot\SoftwareDistribution\Download",
    "$env:SystemRoot\Temp",
    "$env:SystemRoot\Logs",
    "$env:SystemRoot\WinSxS",
    "$env:LOCALAPPDATA\Temp"
)

foreach ($folder in $folders) {
    try {
        if (-not (Test-Path $folder)) {
            Write-Host ("{0,-60} | Non trouvé" -f $folder) -ForegroundColor Yellow
            continue
        }

        # Garde-fou : certains dossiers nécessitent admin
        if (($folder -like "$env:SystemRoot\*") -and -not $IsAdmin) {
            Write-Host ("{0,-60} | Accès refusé (non admin)" -f $folder) -ForegroundColor Yellow
            continue
        }

        $files = Get-ChildItem -Path $folder -File -ErrorAction SilentlyContinue
        $count = $files.Count
        $sizeMB = [math]::Round(($files | Measure-Object Length -Sum).Sum / 1MB, 1)
        Write-Host ("{0,-60} | {1,5} fichiers | {2,8} Mo" -f $folder, $count, $sizeMB)
    }
    catch {
        Write-Host ("{0,-60} | Erreur d'accès" -f $folder) -ForegroundColor Red
    }
}


# ====================================================================
# BLOC 11e : APPLICATIONS INSTALLÉES (HKLM + HKCU)
# ====================================================================
Write-Host "`n=== Applications installées (HKLM + HKCU) ===" -ForegroundColor Cyan

try {
    $regPaths = @(
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*",
        "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*",
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*"
    )

    $apps = foreach ($path in $regPaths) {
        if (Test-Path $path) {
            Get-ItemProperty $path -ErrorAction SilentlyContinue | Where-Object {
                $_.DisplayName -and $_.DisplayName.Trim() -ne ""
            } | Select-Object `
                @{Name="Nom";Expression={$_.DisplayName}},
                @{Name="Version";Expression={$_.DisplayVersion}},
                @{Name="DateInstall";Expression={$_.InstallDate}},
                @{Name="Source";Expression={$path.Split("\")[0]}}
        }
    }

    if ($apps) {
        # Impression compacte sans saut de ligne superflu
        $apps | Sort-Object Nom | Format-Table -AutoSize | Out-String -Stream | ForEach-Object {
            if ($_ -ne "") { Write-Host $_ }#madebygruber with openai
        }
    }
    else {
        Write-Host "Aucune application trouvée dans HKLM/HKCU." -ForegroundColor Green
    }
}
catch {
    Write-Host "Erreur lors de la récupération des applications." -ForegroundColor Red
}


# ====================================================================
# BLOC 12 : EVENT VIEWER (24 dernières heures) - Compact & Aligné
# ====================================================================
Write-Host "`n=== Analyse Event Viewer (24 dernières heures) ===" -ForegroundColor Cyan
$IsAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)

if (-not $IsAdmin) {
    Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow
} else {
    $Since = (Get-Date).AddHours(-24)
    $MainLogs = @("System","Application","Security","Setup")

    # Limite à 300 events par log pour performance
    $Events24h = foreach ($log in $MainLogs) {
        Get-WinEvent -FilterHashtable @{LogName=$log; StartTime=$Since} -MaxEvents 300 -ErrorAction SilentlyContinue
    }

    $CountCritical = ($Events24h | Where-Object { $_.Level -eq 1 }).Count
    $CountError    = ($Events24h | Where-Object { $_.Level -eq 2 }).Count #par ci et par là

    Write-Host "Critiques (24h): $CountCritical"
    Write-Host "Erreurs   (24h): $CountError"
    Write-Host "--- 10 dernières ERREURS ---" -ForegroundColor Yellow

    $LastErrors = $Events24h |
        Where-Object { $_.Level -eq 2 } |
        Sort-Object TimeCreated -Descending |
        Select-Object -First 10 TimeCreated, ProviderName, LogName, Message

    foreach ($err in $LastErrors) {
        # Message propre = 1 ligne, tronqué à 120 caractères
        $msg = ($err.Message -replace '\r?\n',' ' -replace '\s+',' ').Trim()
        if ($msg.Length -gt 120) { $msg = $msg.Substring(0,120) + "..." }

        # Colonnes fixes : Source=40, Log=15
        Write-Host ("[{0:dd.MM.yyyy HH:mm:ss}] | Source:{1,-40} | Log:{2,-15} | {3}" -f `
            $err.TimeCreated, $err.ProviderName, $err.LogName, $msg)
    }
}


# ====================================================================
# BLOC 13 : SANTE MATERIEL - TEMPERATURE CPU
# ====================================================================
Write-Host "`n=== Température CPU ===" -ForegroundColor Cyan
try {
    $temps = Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace root/wmi -ErrorAction Stop
    $zonesUtiles = $temps | Where-Object { $_.InstanceName -match "CPU|GFX|PCH" }
    if ($zonesUtiles) {
        foreach ($t in $zonesUtiles) {
            $celsius = ($t.CurrentTemperature / 10) - 273.15
            $msg = ("Zone: {0,-20} | Temp: {1,5:N1} °C" -f $t.InstanceName, $celsius)
            if ($celsius -lt 60) { Write-Host $msg -ForegroundColor Green }
            elseif ($celsius -lt 80) { Write-Host $msg -ForegroundColor Yellow }
            else { Write-Host $msg -ForegroundColor Red }
        }
    } else {
        Write-Host "Non disponible (pas de capteur)" -ForegroundColor Yellow
    }
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }

# ====================================================================
# BLOC 13a : SANTE MATERIEL - SMART DISQUES
# ====================================================================
Write-Host "`n=== État SMART des disques ===" -ForegroundColor Cyan
try {
    $disks = Get-PhysicalDisk | Get-StorageReliabilityCounter -ErrorAction Stop
    if ($disks -and $disks.Count -gt 0) {
        foreach ($d in $disks) {
            Write-Host ("{0,-20} | État: {1,-10} | Secteurs réalloués: {2}" -f `
                $d.FriendlyName, $d.HealthStatus, $d.ReallocatedSectorsCount)
        }
    } else { Write-Host "Aucun disque compatible SMART détecté." }
}
catch { Write-Host "Non accessible (droits admin requis)" -ForegroundColor Yellow }

# ====================================================================
# BLOC 14 : PERIPHERIQUES EN ERREUR (CRITIQUES UNIQUEMENT)
# ====================================================================
Write-Host "`n=== Périphériques en erreur (drivers) ===" -ForegroundColor Cyan
try {
    $badDevices = Get-CimInstance  Win32_PnPEntity | Where-Object { $_.ConfigManagerErrorCode -ne 0 }
    if ($badDevices) {
        foreach ($dev in $badDevices) {#madebygruber
            Write-Host ("{0} | Code: {1}"  -f $dev.Name, $dev.ConfigManagerErrorCode)
        }
    } else {
        Write-Host "Aucun périphérique en erreur détecté." -ForegroundColor Green
    }
}
catch {
    Write-Host "Impossible de récupérer les périphériques." -ForegroundColor Yellow
}

# ====================================================================
# BLOC 15 : POLITIQUES (AD GPO ou MDM Intune)
# ====================================================================
Write-Host "`n=== Politiques appliquées ===" -ForegroundColor Cyan

# Vérifie si machine est Azure AD Join
$dsreg = dsregcmd /status

if ($dsreg -match "AzureAdJoined\s*:\s*YES") {
    Write-Host "Cet appareil est Azure AD Join : pas de GPO classiques." -ForegroundColor Yellow
    Write-Host "Les politiques proviennent d'Intune / MDM." -ForegroundColor DarkGray

    try {
        $mdmPolicies = Get-WinEvent -LogName Microsoft-Windows-DeviceManagement-Enterprise-Diagnostics-Provider/Admin |
                       Where-Object { $_.Message -like "*PolicyManager MDM*" } |
                       Select-Object TimeCreated, Message |
                       Sort-Object TimeCreated -Descending |
                       Select-Object -First 10

        if ($mdmPolicies) {
            Write-Host "Dernières politiques MDM reçues (résumé)" -ForegroundColor Cyan
            foreach ($p in $mdmPolicies) {
                # Extraction simple de la Zone et de la Stratégie avec RegEx
                if ($p.Message -match "Stratégie : \((?<Strategy>.+?)\).*Zone : \((?<Zone>.+?)\)") {
                    $strategy = $matches['Strategy']
                    $zone     = $matches['Zone']
                    Write-Host ("[{0}] {1,-10} : {2}" -f $p.TimeCreated, $zone, $strategy) -ForegroundColor DarkGray
                }
                else {
                    # fallback si parsing échoue
                    Write-Host ("[{0}] {1}" -f $p.TimeCreated, $p.Message) -ForegroundColor DarkGray
                }
            }
        } else {
            Write-Host "Aucune politique MDM détectée dans les journaux." -ForegroundColor Yellow
        }
    }
    catch {
        Write-Host "Impossible de lire les politiques MDM." -ForegroundColor Red
    }
}
else {
    Write-Host "Cet appareil est AD Join : affichage des GPO." -ForegroundColor Yellow
    try {
        [xml]$xml = Get-GPResultantSetOfPolicy -ReportType Xml -Path "$env:TEMP\gpo.xml"
        
        Write-Host "`n--- Côté Ordinateur ---" -ForegroundColor Cyan
        if ($xml.Rsop.ComputerResults.GPO) {
            $xml.Rsop.ComputerResults.GPO | ForEach-Object {
                Write-Host (" - {0}" -f $_.Name) -ForegroundColor DarkGray
            }
        } else {
            Write-Host "Aucune GPO appliquée côté ordinateur." -ForegroundColor Yellow
        }

        Write-Host "`n--- Côté Utilisateur ($env:USERNAME) ---" -ForegroundColor Cyan
        if ($xml.Rsop.UserResults.GPO) {
            $xml.Rsop.UserResults.GPO | ForEach-Object {
                Write-Host (" - {0}" -f $_.Name) -ForegroundColor DarkGray
            }
        } else {
            Write-Host "Aucune GPO appliquée côté utilisateur." -ForegroundColor Yellow
        }
    }
    catch {
        Write-Host "Impossible de récupérer la liste des GPO (droits admin requis ?)." -ForegroundColor Red
    }
}

# ====================================================================
# FIN DU DIAGNOSTIC
# ====================================================================
try {  Stop-Transcript | Out-Null}
catch { }

if ($rapportPath -ne $null) {
    Write-Host "`n`n`nRapport complet exporté vers : $rapportPath" -ForegroundColor Cyan}
else {   Write-Host "`n`n`nFin du diagnostic" -ForegroundColor Cyan}
